/*
 * @param in the value to constrain
 * @param limit the magnitude to constrain to
 */
int limitTo(int in, int limit){
  if(in<-limit) return -limit;
  else if(in>limit) return limit;
  else return in;
}

/*
 * @param port the motor port to run
 * @param power the speed to run it at, scaled from -100 to +100
 * @param brake whether or not to brake when power = 0
 */
inline void runMotor(byte port, int power, bool brake=false){
  if(power>100)
    power=100;
  if(power<-100)
    power=-100;
  if (power>0){
    OnFwdEx(port, power, RESET_NONE);
  }else if(power<0){
    OnRevEx(port, -power, RESET_NONE);
  }else if(brake){
    OffEx(port, RESET_NONE);
  }else{
    CoastEx(OUT_BC,RESET_NONE);
  }
}

// Direction to turn the turret to in degrees
float turretSetpoint=0;

/*
 * Turn on the drivetrain to output values corresponding to the given vectors.
 * @param y the forwards-backwards speed vector
 * @param w the rotational speed vector
 */
void drive (int y, int w) {
  if (abs(w)<2) {
    // If the rotation vector is negligible, just skip expensive computations.
    turretSetpoint = 0;
    
    runMotor(OUT_B, -y, false);
    runMotor(OUT_C, -y, false);
  } else {
    // Get basic gist of the vectors
    int left = y-w;
    int right = y+w;
    // Scale them down appropriately so that neither one is larger than 100.
    /// If we don't do this, the output tank values will not correspond to the turret.
    if (abs(left)>abs(right)) {
      if (abs(left)>100) {
        right = right*abs(left)/100;
        left = abs(left)/left*100;
      }
    } else {
      if (abs(right)>100) {
        left = left*abs(right)/100;
        right = abs(right)/right*100;
      }
    }
    // Write values out
    runMotor(OUT_B, -left, false);
    runMotor(OUT_C, -right, false);
    // Compute turning radius, measured in wheelbase width/2
    float radius = (left+right)/(right-left); 
    // compute angle to turn to.
    // The turret is the wheelbase width back from the drive axle, so use 2.0
    turretSetpoint = atan2d(2.0,radius);
  }
}

// Holds the turret at the desired setpoint
task turretRegulator() {
  ResetTachoCount(OUT_A);
  while(true){
    // Get general error
    float error = -turretSetpoint-((MotorRotationCount(OUT_A))*40.0/56.0);
    // Optimize error by subtracting or adding 180 to it until it is within the range of -90,+90.
    while(error>90) error-=180;
    while(error<-90) error+=180;
    // Set output value
    runMotor(OUT_A,error*7);

    Wait(3);
    KeepAliveType kaArgs;
  SysKeepAlive(kaArgs);
  }
}

#define SETPOINT 110

#define KP 0.35
#define KI 0
#define MAXI 1000
#define KD 0

#define DAMPING 100

long integral=0;
long lastError=0;
long lastResp = 0;

task main() {
  start turretRegulator;

  SetSensorColorFull(S4);
  ColorSensorReadType ground;

  ground.Port=S4;

  while(true){  // While we haven't reached the end
    SysColorSensorRead(ground);
    long error=ground.NormalizedArray[2]-SETPOINT;
    integral+=error;
    integral=limitTo(integral, MAXI);

    long resp = error*KP+integral*KI+(error-lastError)*KD;
    if (lastResp+DAMPING < resp) resp = lastResp+DAMPING;
    if (lastResp-DAMPING > resp) resp = lastResp-DAMPING;
    drive(50,resp);

    lastError=error;
    lastResp = resp;


    ResetSleepTimer();
    // Don't fall asleep.
    Wait(1);
    // Wait so that our integral isn't racked up instantaneously.
  }
}